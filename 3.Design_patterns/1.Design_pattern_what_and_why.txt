-> Designing object oriented software is hard.
-> Designining Reusable object oriented software is even harder.E.g:- redux , react,any GUI library
-> Understaning design patterns will let us become framework/library CREATOR rather than only 
CONSUMER.
-> Consequently, we'll find recurring patterns of classes and communicating objects in many 
object-oriented systems.
-> These patterns solve specific design problems and make object-oriented designs more flexible,
elegant, and ultimately reusable.
-> Design patterns are way of organizing classes and objects , to design or solve a particular 
problem or system.


1. Architectural Styles
Architectural styles tell us, in very broad strokes, how to organise our code. 
It’s the highest level of granularity and it specifies layers, high-level modules of the application 
and how those modules and layers interact with each other, the relations between them. 
Examples of Architectural Styles:

* Component-based
* Monolithic application
* Layered
* Pipes and filters
* Event-driven
* Publish-subscribe
* Plug-ins
* Client-server
* Service-

2. Architectural Patterns
A pattern is a recurring solution to a recurring problem. In the case of Architectural Patterns, 
they solve the problems related to the Architectural Style. For example, “what classes will we have 
and how will they interact, in order to implement a system with a specific set of layers“, or 
“what high-level modules will have in our Service-Oriented Architecture and how will they communicate“, 
or “how many tiers will our Client-server Architecture have“.

Architectural Patterns have an extensive impact on the code base, most often impacting the whole
application either horizontally (ie. how to structure the code inside a layer) or vertically 
(ie. how a request is processed from the outer layers into the inner layers and back). 
Examples of Architectural Patterns:

* Three-tier
* Microkernel
* Model-View-Controller
* Model-View-ViewModel


3. Design Patterns
Design Patterns differ from Architectural Patterns in their scope, they are more localised, 
they have less impact on the code base, they impact a specific section of the code base, 
for example:

* How to instantiate an object when we only know what type needs to be instantiated at run time 
(maybe a Factory Class?);
* How to make an object behave differently according to its state (maybe a state machine, or a 
Strategy Pattern?).
